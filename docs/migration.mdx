Migrating to Indexify is easy! Pretty much every multi-stage application code can be ported with minimal changes.

Here is an example of incrementatl adoption of Indexify in your codebase -

## Original Code 

```python
def chunk(doc: str) -> list[str]:
    return doc.split("\n")

def embed_chunk(chunk: str) -> List[float]:
    return embed(chunk)


### Application code 
def myapp(docs: List[str]) -> List[List[float]]:
    chunks = [chunk(doc) for doc in docs]
    embeddings = [embed_chunk(chunk) for chunk in chunks]
    return embeddings
```

## Migration Steps

We will create a **remote** API that accepts a document, and chunks and returns the embeddings. 
It will be callable from any application code.

### Decorate functions which are units of work
    
    ```python
    @indexify_function()
    def chunk(doc: str) -> list[str]:
        return doc.split("\n")
    
    @indexify_function()
    def embed_chunk(chunk: str) -> List[float]:
        return embed(chunk)

    @indexify_function()
    def myapp(docs: List[str]) -> List[List[float]]:
        chunks = [chunk(doc) for doc in docs]
        embeddings = [embed_chunk(chunk) for chunk in chunks]
        return embeddings
    ```

### Define and Deploy the Graph
    
```python
from indexify import RemoteGraph, Graph
g = Graph(start_node=chunk)
g.add_edge(chunk, embed_chunk)


graph = RemoteGraph.deploy(g)
```

### Call the Graph like a function 

```python
docs = ["doc1", "doc2", "doc3"]
for doc in docs:
    invocation_id = graph.run(block_until_done=True, doc=doc)
    embeddings: List[List[float]] = graph.output(invocation_id, "embed_chunk")
```